# AnnotationKiller

> 利用状态机删除 `C/C++` 代码中的注释

- [AnnotationKiller](#annotationkiller)
  - [参考](#参考)
  - [编译](#编译)
  - [运行](#运行)
  - [实现思路](#实现思路)

## 参考

- [https://www.cnblogs.com/xiaoxi666/p/7931763.html](https://www.cnblogs.com/xiaoxi666/p/7931763.html)
- [https://www.cnblogs.com/zhanghaiba/p/3569928.html#3853787](https://www.cnblogs.com/zhanghaiba/p/3569928.html#3853787)

## 编译

在当前文件夹下

```
make
```

## 运行

```
./delet <原始文件名> [目标文件名]
```

提供一个测试文件 `test.cpp`

## 实现思路

以 C/C++ 为例，需要考虑的情况有

1. **设正常状态为0，并初始为正常状态。** 每遍历一个字符，就依次检查下列条件，若成立或全部检查完毕，则回到这里检查下一个字符
2. **状态0中遇到\/，说明可能会遇到注释，则进入状态1。** `int a = b; /`
3. **状态1中遇到\*，说明进入多行注释部分，则进入状态2。** `int a = b; /*`
4. **状态1中遇到\/，说明进入单行注释部分，则进入状态4。** `int a = b; //`
5. **状态1中没有遇到(不是紧接着)\*或/，说明/是路径符号或除号，恢复状态0。** `<sys/socket.h>` 或 `5/3`
6. **状态2中遇到\*，说明多行注释可能要结束，则进入状态3。** `int a = b; /*heh*`
7. **状态2中不是遇到\*，说明多行注释还在继续，维持状态2。**
8. **状态3中遇到/，说明多行注释已经结束，恢复状态0。**
9. **状态4中遇到\，说明可能进入折行注释部分，则进入状态9。** `int a = b; // annotation \`
10. **状态9中遇到\\，说明进入折行注释部分，维持状态9。** `int a = b; // annotation \\`
11. **状态9中遇到其他字符，说明进入折行注释部分，进入状态4。** `int a = b; // annotation \ comment`
12. **状态4中遇到回车符\n,说明单行注释结束，恢复状态0。** `int a = b // hehe <enter>`
13. **状态0中遇到',说明进入字符常量中，则进入状态5。** `char a = '`
14. **状态5中遇到\,说明遇到转义字符，则进入状态6。** `char a = '\`
15. **状态6中遇到任何字符，进入状态5。** `char a = '\n \t \'` 主要是为了防止遇到 `'\'` 而误以为结束。
16. **状态5中遇到'，说明字符串常量结束，进入状态0。**  `char a = '\n'`
17. **状态0中遇到"，说明进入字符串常量中，则进入状态7。** `char s[] = "` 或者 `string s = "`
18. **状态7中遇到\，说明遇到转义字符，则进入状态8。** `char s[] = "\`
19. **状态8中遇到任何字符，都恢复状态7。** `char s[] = "\n` 主要是为了防止遇到 `char s[] = "\"` 误以为结束。
20. **状态7中遇到"，说明字符串常量结束，恢复状态0。** `char s[] == "\""`

那么可以画出状态转移图

![fsm](./figs/fsm.svg)
